" remind, after add: :helptags ALL

" load setings common to 'page'
:luafile ~/.nvim.light.init.lua

" [[[ main settings

:lua vim.api.nvim_set_option_value('number', true, {win = 0})
:lua vim.api.nvim_set_option_value('relativenumber', true, {win = 0})
:lua vim.api.nvim_set_option('laststatus', 2)
:lua vim.api.nvim_set_option('ruler', true)
:lua vim.api.nvim_set_option('showcmd', true)
:lua vim.api.nvim_set_option('shadafile', "")

" ]]]
" [[[ main settings cont'd

" old options dropped during lua convertion
" set sessionoptions=buffers,folds,localoptions,options,tabpages,help
" set sessionoptions-=blank       " for syntastic

" ]]]
" [[[ Mappings

:lua vim.api.nvim_set_keymap('n', '<C-PageDown>', ':bnext<cr>', { noremap = true })
:lua vim.api.nvim_set_keymap('n', '<C-PageUp>', ':bprevious<cr>', { noremap = true })

:lua vim.api.nvim_set_keymap('n', '<kPlus>', ':cnext<CR>zv<CR>', { noremap = true })
:lua vim.api.nvim_set_keymap('n', '+', ':cnext<CR>zv<CR>', { noremap = true })
:lua vim.api.nvim_set_keymap('n', '<kMinus>', ':cprevious<CR>zv<CR>', { noremap = true })
:lua vim.api.nvim_set_keymap('n', '_', ':cprevious<CR>zv<CR>', { noremap = true })
:lua vim.api.nvim_set_keymap('n', '-', ':cprevious<CR>zv<CR>', { noremap = true })

" disable number / relativenumber for big files, to avoid to read to count lines
:lua << LUA
vim.api.nvim_create_autocmd('BufReadPre', {                     
	pattern = '*',                                               
	callback = function(args)                                    
		-- local cur_buf = vim.api.nvim_get_current_buf()           
		-- local cur_name = vim.api.nvim_buf_get_name(cur_buf)          
		-- local cur_sz = vim.fn.getfsize(cur_name)                     
		local cur_sz = vim.fn.getfsize(args.file)                     
		if cur_sz > 20 * 1024 * 1024 then                        
			vim.bo.ft = large                            
			vim.bo.swapfile = false                      
			vim.bo.bufhidden = unload                    
			vim.bo.undolevels = -1                       
			vim.wo.foldmethod = manual                   
			vim.wo.foldenable = false                    
			vim.wo.number = false                        
			vim.wo.relativenumber = false                
			vim.opt_local.backup = false                       
			vim.opt_local.writebackup = false                  
			vim.opt_local.eventignore:append('FileType')        
		else                                                 
			vim.opt_local.eventignore:remove('FileType')        
		end                                                  
	end                                                          
	})
    -- autocmd Filetype * if getfsize(@%) > 1000000 | setlocal syntax=OFF | endif

    -- open the quick list window after make
    -- autocmd QuickFixCmdPost [^l]* nested botright cwindow 10
    -- TODO really required?
vim.api.nvim_create_autocmd('QuickFixCmdPost', {                     
	pattern = '[^l]*',                                               
	nested = true,
	command = "botright cwindow 10"
	})
	
-- quickfix: jump on top, disable line numbers
-- autocmd BufWinEnter quickfix exe "normal! zt"
-- autocmd BufWinEnter quickfix set nonumber
-- autocmd BufWinEnter quickfix set norelativenumber
vim.api.nvim_create_autocmd({ 'VimEnter', 'WinEnter', 'BufWinEnter'}, {
  pattern = '*',
  callback = function()
    if vim.bo.filetype == 'quickfix' then
	vim.cmd('exe "normal! zt"')
	vim.wo.number = false                        
	vim.wo.relativenumber = false                
	vim.wo.signcolumn = 'no'
    end
  end,
})

-- Have <esc> or mine C-j leave cmdline-window
-- Disable line numbers in command line window
vim.api.nvim_create_autocmd('CmdWinEnter', {
  callback = function()
    vim.keymap.set('n', '<ESC>', ':q<CR>', { noremap = true })
    vim.keymap.set('n', '<C-j>', ':q<CR>', { noremap = true })
    vim.wo.number = false
    vim.wo.relativenumber = false
    vim.wo.signcolumn = 'no'
  end,
})
-- restore mapping when leaving
vim.api.nvim_create_autocmd('CmdWinLeave', {
  callback = function()
    vim.keymap.del('n', '<ESC>')
    vim.keymap.del('n', '<C-j>')
  end,
})

-- map C-h to get cursor position by toggle cursorlines
vim.keymap.set('n', '<C-H>', function()
  vim.wo.cursorline = not(vim.wo.cursorline)
  vim.wo.cursorcolumn = not(vim.wo.cursorcolumn)
end, { noremap = true })

-- highlight yanked text
vim.api.nvim_create_autocmd('TextYankPost', {
  command = 'silent! lua vim.highlight.on_yank({ timeout = 500 })'
})

-- ]]]
-- [[[ filetypes

-- allow to use :let per buffer, when adding on first/last lines stuff like:
-- // VIM: let b:syntastic_c_cflags = "-DMACRO_XXX=2"
-- autocmd BufNewFile * let b:this_is_new_buffer=1
vim.api.nvim_create_autocmd({ 'BufNewFile'}, {
  pattern = '*',
  callback = function()
     vim.cmd('let b:this_is_new_buffer=1')
  end,
})
vim.api.nvim_create_autocmd({ 'BufEnter'}, {
  pattern = '*',
  callback = function()
     vim.cmd('call FirstModeLine()')
  end,
})

-- always backup session (reopen via vl alias)
-- autocmd VimLeave * mksession! ~/.cache/session.vim
vim.api.nvim_create_autocmd({ 'VimLeave'}, {
  pattern = '*',
  callback = function()
     vim.cmd('mksession! ~/.cache/session.vim')
  end,
})

-- remove trailing whitespace at write
vim.api.nvim_create_autocmd({ 'BufWritePre' }, {
  pattern = '*',
  callback = function()
    if vim.bo.filetype == 'c'
    or vim.bo.filetype == 'cpp'
    or vim.bo.filetype == 'mail'
    or vim.bo.filetype == 'asciidoc'
    or vim.bo.filetype == 'python'
    or vim.bo.filetype == 'gitcommit'
    or vim.bo.filetype == 'rust'
    then
      vim.cmd[[ :%s/\s\+$//e ]]
    end
  end,
})
LUA

" ]]]
" [[[ weird (outdated?) options

let git_diff_spawn_mode=2
let git_diff_opts = "--no-renames --summary -C -M"
let c_gnu=1
let c_space_errors=1
let c_no_curly_error=1

let g:is_bash=1
let g:sh_fold_enabled=1

" String to put at the start of lines that have been wrapped
let &showbreak='‚Ü™ '

" ]]]
" [[[ man plugin

if !has('nvim')
    runtime! ftplugin/man.vim      " to get pretty :Man
    nmap K :Man <C-R>=expand("<cword>")<CR><CR>
endif
" default for nvim

" activate matchit
if has('nvim')
   let loaded_matchit = 1
endif

" ]]]
" [[[ misc map

" ESC with CTR-j
inoremap <C-j> <esc>l
vnoremap <C-j> <esc>
nnoremap <C-j> <esc>

" ]]]
" [[[ tags & cscope

" g\ ->open tag of the word under cursor on a new window at right
" nnoremap g\ <ESC>:vert :rightbelow :scscope <C-R>=expand("<cword>")<CR><CR>
" nnoremap <C-\> <ESC>:vert :rightbelow :split :cstag <C-R>=expand("<cword>")<CR><CR>

function! GetVisualSelection()
    let [s:lnum1, s:col1] = getpos("'<")[1:2]
    let [s:lnum2, s:col2] = getpos("'>")[1:2]
    let s:lines = getline(s:lnum1, s:lnum2)
    let s:lines[-1] = s:lines[-1][: s:col2 - (&selection == 'inclusive' ? 1 : 2)]
    let s:lines[0] = s:lines[0][s:col1 - 1:]
    return join(s:lines, ' ')
endfunction

" "all symbol
" nnoremap <leader>s <ESC>:vert :rightbelow :scscope find s <C-R>=expand("<cword>")<CR><CR>
" vnoremap <leader>s <ESC>:execute ':vert :rightbelow :scscope find s '.GetVisualSelection()<CR>
" "go to definition
" "nnoremap <C-]> <ESC>:cstag <C-R>=expand("<cword>")<CR><CR>
" nnoremap <C-]> <ESC>:scscope find g <C-R>=expand("<cword>")<CR><CR>
" vnoremap <C-]> <ESC>:execute ':cstag '.GetVisualSelection()<CR>
" "go to definition / ctags version
" nnoremap <C-p> <ESC>:tjump <C-R>=expand("<cword>")<CR><CR>
" vnoremap <C-p> <ESC>:execute ':tjump '.GetVisualSelection()<CR>
"
" "nnoremap <C-\> <ESC>:vert :rightbelow :cstag <C-R>=expand("<cword>")<CR><CR>
" nnoremap <C-\> <ESC>:vert :rightbelow :scscope find g <C-R>=expand("<cword>")<CR><CR>
" "vnoremap <C-\> <ESC>:execute ':vert :rightbelow :cstag '.GetVisualSelection()<CR>
" vnoremap <C-\> <ESC>:execute ':vert :rightbelow :scscope find g '.GetVisualSelection()<CR>
" "calling this function
" nnoremap <leader>c <ESC>:vert :rightbelow :scscope find c <C-R>=expand("<cword>")<CR><CR>
" vnoremap <leader>c <ESC>:execute ':vert :rightbelow :scscope find c '.GetVisualSelection()<CR>
" "go to definition (cscope shortcut are weird)
" nnoremap <leader>d <ESC>:vert :rightbelow :scscope find g <C-R>=expand("<cword>")<CR><CR>
" vnoremap <leader>d <ESC>:execute ':vert :rightbelow :scscope find g '.GetVisualSelection()<CR>
" "including this file
" nnoremap <leader>i <ESC>:vert :rightbelow :scscope find i <C-R>=expand("<cword>")<CR><CR>
" vnoremap <leader>i <ESC>:execute ':vert :rightbelow :scscope find i '.GetVisualSelection()<CR>
" "find this text (avoid Ggrep)
" nnoremap <leader>t <ESC>:vert :rightbelow :scscope find t <C-R>=expand("<cword>")<CR><CR>
" vnoremap <leader>t <ESC>:execute ':vert :rightbelow :scscope find t '.GetVisualSelection()<CR>
" nnoremap <C-t> <ESC>:cscope find t <C-R>=expand("<cword>")<CR><CR>
" vnoremap <C-t> <ESC>:execute ':cscope find t '.GetVisualSelection()<CR>
"
" "manual jumpt to <args>
" command! -nargs=1 Find cscope find g <args>
" command! -nargs=1 VFind vert rightbelow scscope find g <args>

" indent/deindent: stay in visual mode
vnoremap < <gv
vnoremap > >gv

" move text up/down in visual
vnoremap <S-j> :move '>+1<CR>gv=gv
vnoremap <S-k> :move '<-2<CR>gv=gv

" clean empty lines
vnoremap <leader>l :g/^$/d<CR>

" ]]]
" [[[ macros

" tt is command to align on space
cab tt Tabularize /\S\+;

"" Toggle &virtualedit
function! Toggle_virtualedit_()
  if &virtualedit == 'all'
    set virtualedit=onemore " be on ending \n
  else
    set virtualedit=all
  endif
endfunction
" map <F7> <ESC>:call Toggle_virtualedit_()<CR>:set virtualedit?<CR>

:lua << LUA
-- map C-h to get cursor position by toggle cursorlines
vim.keymap.set({'i', 'n'}, '<F7>', function()
	if vim.wo.virtualedit == 'onemore'
	then
		vim.wo.virtualedit = 'all'
		print('virtualedit on')
	else
		vim.wo.virtualedit = 'onemore'
		print('virtualedit off')
	end
end,
	{ noremap = true })
LUA

" C preprocessor macro management (iCTRL-vCTRL-m to insert real <CR>)
let @l=':set virtualedit =allgv:s/\(\s\|\\\)\+$//gegv:norm 78|C\:call Toggle_virtualedit_():nohlsearchgvj'
" vim.fn.setreg('l', ':set virtualedit =allgv:s/\(\s\|\\\)\+$//gegv:norm 78|C\:call Toggle_virtualedit_():nohlsearchgvj')
let @m=':set virtualedit =all?#definev}kk:''<,''>s/\(\s\|\\\)\+$//gegv:norm 78|C\:call Toggle_virtualedit_():nohlsearchgvj'
" vim.fn.setreg('m', ':set virtualedit =all?#definev}kk:''<,''>s/\(\s\|\\\)\+$//gegv:norm 78|C\:call Toggle_virtualedit_():nohlsearchgvj')

" when solving a git conflict, extract next hunk and open 2 tabs with diff of ancestor vs. new branch and ancestor vs. current HEAD
" reg f = name of HEAD
" reg e = name of common ancestor branch
" reg d = name of the new branch
" reg x = HEAD
" reg y = common ancestor branch
" reg z = new branch
" marks:
" <<<<<<< HEADa
" 1
" 1b
" ||||||| merged common ancestors
" 2
" 2c
" =======
" 3
" 3d
" >>>>>>> new branch
let @c=':tabonly0/HEAD"fy$$j0ma/|||||||W"ey$0k$mb0j/=======k$mc0j/>>>>>>>W"dy$0k$md0j`a"xy`b`b0jj"yy`c`c0jj"zy`d`a:tabnew"yP:diffthis:noswapfile :file /tmp/=substitute(@e,"[ /]","_","g"):setlocal buftype=nofile nomodified bufhidden=wipe:vert :rightb :new"zP:diffthis:noswapfile :file /tmp/=substitute(@d,"[ /]","_","g"):setlocal buftype=nofile nomodified bufhidden=wipe:tabnew"yP:diffthis:noswapfile :file /tmp/=substitute(@e,"[ /]","_","g").2:setlocal buftype=nofile nomodified bufhidden=wipe:vert :rightb :new"xP:diffthis:noswapfile :file /tmp/=substitute(@f,"[ /]","_","g"):setlocal buftype=nofile nomodified bufhidden=wipe:tabprevious:let@/="HEAD"'

" ]]]
" [[[ maps

" disable arrow keys
:lua << LUA
vim.keymap.set({'n', 'i'}, '<up>', '<nop>', { noremap = true })
vim.keymap.set({'n', 'i'}, '<down>', '<nop>', { noremap = true })
vim.keymap.set({'n', 'i'}, '<left>', '<nop>', { noremap = true })
vim.keymap.set({'n', 'i'}, '<right>', '<nop>', { noremap = true })
LUA

" use real line movement when used without <count>
noremap <silent> <expr> j (v:count == 0 ? 'gj' : 'j')
noremap <silent> <expr> k (v:count == 0 ? 'gk' : 'k')

:lua << LUA
-- open command-line window directly
-- nnoremap <leader>; :
vim.keymap.set('n', '<leader>;', ':', { noremap = true })
-- open command-line window with history 
-- noremap q; q:
vim.keymap.set('n', 'q;', 'q:', { noremap = true })
-- note that q/ or q? open search-line window with history

-- in insert mode, C-o do completion previous and C-n do a normal command
vim.keymap.set('i', '<C-o>', '<C-n>', { noremap = true })
vim.keymap.set('i', '<C-n>', '<C-o>', { noremap = true })

-- command line mode: navigation exactly as own bash navigation
-- remind that C-f pop up command line window
vim.keymap.set('c', '<C-a>', '<Home>', { noremap = true })
vim.keymap.set('c', '<C-e>', '<End>', { noremap = true })
vim.keymap.set('c', '<C-o>', '<Down>', { noremap = true })
vim.keymap.set('c', '<C-v>', '<Right>', { noremap = true })
vim.keymap.set('c', '<C-n>', '<Left>', { noremap = true })
vim.keymap.set('c', '<C-g>', '<Del>', { noremap = true })
vim.keymap.set('c', '<C-h>', '<BackSpace>', { noremap = true })
vim.keymap.set('c', '<C-j>', '<C-c>', { noremap = true })

-- ]]]
-- [[[ macros cont'd

-- map to remove trailing spaces
-- nnoremap <Leader>b :s/\s\+$//e<CR>
-- vnoremap <Leader>b :s/\s\+$//e<CR>

-- alias M for make
vim.keymap.set('n', '<Leader>m', '<ESC>:wall<CR>:make<CR>', { noremap = true })
-- vim.keymap.set('n', '<Leader>M', '<ESC>:wall<CR>:set shell=/bin/bash\ -i<CR>:! mn<CR>:set shell=/bin/bash<CR>', { noremap = true })

-- alias x for :x
vim.keymap.set('n', '<Leader>x', '<ESC>:xa<CR>', { noremap = true })

-- " map to append a gerrit's changeId
-- function! Append_gen_changid()
--   " grep -m40 -ao '[0-9a-f]' /dev/urandom | head -n40 | paste -sd '' do the job
--   :read !LANG=C grep -m40 -ao -P '[\x30-\x39\x61-\x66]' /dev/urandom | head -n40 | paste -sd ''
-- endfunction
-- nnoremap <Leader>C <ESC>oChange-Id: I<ESC>:call Append_gen_changid()<CR>kJx<ESC>

-- clear the search register -> like :noh
vim.keymap.set('n', '<Leader>/', ':let@/=""<CR>', { silent = true, noremap = true })

-- git grep on current word
vim.keymap.set('n', '<Leader>g', '<ESC>:Ggrep <C-R>=expand("<cword>")<CR><CR>', { noremap = true })
vim.keymap.set('v', '<Leader>g', '<ESC>:execute \':Ggrep \'.GetVisualSelection()<CR>', { noremap = true })
-- FIXME broken
-- version with prompt before executing
-- nnoremap <Leader>G <ESC>:Ggrep <C-R>=expand("<cword>")<CR>
-- vim.keymap.set('n', '<Leader>G', '<ESC>:Ggrep <C-R>=expand("<cword>")<CR>', { noremap = true })
-- vnoremap <Leader>G <ESC>:execute ':Ggrep '.GetVisualSelection()
-- vim.keymap.set('v', '<Leader>G', '<ESC>:execute \':Ggrep \'.GetVisualSelection()<CR>', { noremap = true })

-- ]]]
-- [[[ colortheme

-- switch light/dark via env variable theme
if vim.env.theme == 'light'
then
  vim.opt.background="light"
else
  vim.opt.background="dark"
end

vim.cmd("packadd kanagawa")
vim.opt.laststatus = 2 -- 3(unique statusline) drops info for no gain
vim.opt.fillchars:append({
    horiz = '‚îÅ',
    horizup = '‚îª',
    horizdown = '‚î≥',
    vert = '‚îÉ',
    vertleft = '‚î®',
    vertright = '‚î£',
    verthoriz = '‚ïã',
})
require('kanagawa').setup {
  undercurl = true,           -- enable undercurls
  commentStyle = { italic = true },
  functionStyle = {},
  keywordStyle = { italic = true},
  statementStyle = { bold = true },
  typeStyle = {},
  transparent = false,        -- do not set background color
  dimInactive = true,        -- dim inactive window `:h hl-NormalNC`
  globalStatus = true,        -- adjust window separators highlight for laststatus=3
  terminalColors = true,      -- define vim.g.terminal_color_{0,17}
  colors = {},
  theme = "default"           -- Load "default" theme or the experimental "light" theme
}
-- vim.opt.winbar = "%=%m %f %n %p%%"
vim.cmd.colorscheme("kanagawa")

-- ]]]
-- [[[ neovim specific

-- neovim default is 'nvi', which is unusable and inhibit ~normal~ copy/paste
vim.opt.mouse = ""

-- exit from term with alt space (not binding by any shell or tool IMHO)
-- tnoremap <A-Space> <C-\><C-n>
vim.keymap.set('t', '<A-Space>', '<C-\\><C-n>', { noremap = true })

-- same history lenght than tmux
vim.cmd[[
let g:terminal_scrollback_buffer_size=99999
]]

-- ]]]
-- [[[ airline options

-- XXX disable laststatus for minimal config

-- FIXME find a clean nvim successor of airline
LUA
:lua << LUA
vim.cmd([[

let g:airline_powerline_fonts=1
let g:airline#extensions#default#layout = [ ['a','b','c'], ['x','y','z','warning'] ]
" suppress hunks from line, they're shown by gitgutter
" let g:airline_section_b = '%{airline#util#wrap(airline#extensions#branch#get_head(),0)}'
let g:airline_section_b = '
    \%{ !empty(get(b:, "gitsigns_head", "")) ? "Óú• " : "" }
    \%{ get(b:, "gitsigns_head", "") }
    \%{ !empty(get(b:, "gitsigns_head", "")) ? " " : "" }
    \%{ get(b:, "gitsigns_status", "") }
    \'
" let g:airline_section_i = '%{fugitive#head()}' " real git msgs
let g:airline_section_x = '%n' " buffer number, will be reset later
let g:airline_section_y = '%{ObsessionStatus(''Ôêì '', '''')}%{airline#util#wrap(airline#parts#filetype(),0)}'
let g:airline_section_z = '%p%% ‚ÑÖ%v' " no line number
let g:airline_theme = "base16"
" let g:airline_theme='solarized'
let g:airline_theme = "base16_tomorrow_night_eighties"
" let g:airline_theme = "base16_spacemacs"
" FIXME use kanagawa's extras/base16-theme.yaml
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#tab_nr_type = 2 " splits and tab number
let g:airline#extensions#tabline#left_sep = ' '
let g:airline#extensions#tabline#left_alt_sep = '|'
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#buffer_idx_mode = 1
nmap <leader>1 <Plug>AirlineSelectTab1
nmap <leader>2 <Plug>AirlineSelectTab2
nmap <leader>3 <Plug>AirlineSelectTab3
nmap <leader>4 <Plug>AirlineSelectTab4
nmap <leader>5 <Plug>AirlineSelectTab5
nmap <leader>6 <Plug>AirlineSelectTab6
nmap <leader>7 <Plug>AirlineSelectTab7
nmap <leader>8 <Plug>AirlineSelectTab8
nmap <leader>9 <Plug>AirlineSelectTab9
nmap <leader>0 <Plug>AirlineSelectTab0
nmap <leader>- <Plug>AirlineSelectPrevTab
nmap <leader>= <Plug>AirlineSelectNextTab
let g:airline#extensions#tabline#formatter = 'unique_tail'
let g:airline#extensions#tabline#show_close_button = 0
let g:airline#extensions#obsession#enabled = 1
let g:airline#extensions#obsession#indicator_text = 'Ôêì' " C-vuf413

" display slime tmux target next to buffer number
function! AirlineSlime()
  if !exists('b:slime_config["target_pane"]')
    return bufnr('%')
  " drop useless :. prefix
  elseif b:slime_config["target_pane"][0:1] == ':.'
    return bufnr('%') . ' ÔÑ†' . b:slime_config["target_pane"][2:]
  endif
  return bufnr('%') . ' ÔÑ†' . b:slime_config["target_pane"]
endfunction
let g:airline_section_x = '%{AirlineSlime()}'

]])
LUA
:lua << LUA

-- ]]]
-- [[[ tmuxline options

LUA
:lua << LUA
vim.cmd([[

let g:airline#extensions#tmuxline#enabled = 1
let g:airline#extensions#tmuxline#color_template = 'visual'
let g:airline#extensions#tmuxline#color_template = 'normal'
let g:airline#extensions#tmuxline#snapshot_file = "~/.config/tmux/tmuxline.cf"
let g:tmuxline_preset = {
  \'a'    : '#S',
  \'win'  : '#I #W #F',
  \'cwin' : '#I #W #F',
  \'x'    : '#(cut -d " " -f 1-4 /proc/loadavg) ',
  \'y'    : '%Y-%m-%d %H:%M:%S ',
  \'z'    : '#H',
  \'options' : {'status-justify' : 'left'}}
let g:tmuxline_separators = {
      \ 'left' : 'ÓÇ∞',
      \ 'left_alt': '>',
      \ 'right' : 'ÓÇ≤',
      \ 'right_alt' : '<',
      \ 'space' : ''}
let g:tmuxline_powerline_separators = 1

]])
LUA
:lua << LUA

-- ]]]
-- [[[ syntastic options

LUA
:lua << LUA
vim.cmd([[

" TODO drop syntastic once LSP works

" XXX Syntastic fails to find your header files? Try 'make syntastic' in the
"     root directory of your repository.

" syntastic sign on one char, not two
let g:syntastic_error_symbol = "‚úó"
let g:syntastic_warning_symbol = "‚ö†"
let g:syntastic_style_error_symbol = 'S'
let g:syntastic_style_warning_symbol = 's'

" javascript makes vim freeze
let g:syntastic_mode_map = { 'mode': 'active',
                           \ 'active_filetypes': [ 'python', 'sh', 'php', 'c', 'cpp' ],
                           \ 'passive_filetypes': [ 'javascript'] }
" avoid error on generated by build include file
let g:syntastic_ignore_files = [ '\m^/usr/include/' ]
let g:syntastic_auto_loc_list=1
let g:syntastic_auto_jump=0
let g:syntastic_check_on_open=0
let g:syntastic_silent_make=0
let g:syntastic_loc_list_height=3
let g:syntastic_debug=0

]])
LUA
:lua << LUA
vim.cmd([[

let g:syntastic_c_compiler = 'clang'
let g:syntastic_c_compiler = 'gcc'
let g:syntastic_c_compiler_options = ''
let g:syntastic_c_compiler_options = "-std=gnu11 -Wall -Wextra -Wpedantic -DLINUX"
let g:syntastic_c_cflags = ''
" let g:syntastic_c_include_dirs = [ '...' ]
let g:syntastic_c_remove_include_errors = 0 " to avoid report error about unknown include
let g:syntastic_c_no_include_search = 1
let g:syntastic_c_no_default_include_dirs = 1
" let b:syntastic_c_cflags = "-DLINUX"
let g:syntastic_c_check_header = 1

let g:syntastic_cpp_compiler = 'clang++-6.0'
let g:syntastic_cpp_compiler_options = "-std=c++17 -Wall -Wno-unknown-pragmas -Wextra -Wpedantic -DLINUX"
let g:syntastic_cpp_include_dirs = [ '/home/beneyton/utils/boost_1_68_0/include/' ]
let g:syntastic_cpp_check_header = 1
" let g:syntastic_quiet_messages = {
"             \ "file:p":  ['....h'] } " discard report on those files
" suppress all msgpack related warning/error
" let g:syntastic_quiet_messages = {
"         \ "regex":  ['...\|...'],
"         \ "file:p":  ['...\|...'] }


let g:syntastic_cpp_remove_include_errors = 0 " to avoid report error about unknown include
let g:syntastic_cpp_no_include_search = 1
let g:syntastic_cpp_no_default_include_dirs = 1
"let g:syntastic_cpp_config_file='.clang_complete'
" let g:syntastic_cpp_pylint_quiet_messages = { "level": "errors" , \ "file:p": ['.*config.h'] }

let g:syntastic_python_compiler = 'pylint'
let g:syntastic_python_compiler_options = '--errors-only --rcfile=/home/richard/.pylintrc'
let g:syntastic_python_pylint_quiet_messages = { "level": "warnings" }

" disable syntastic for asciidoc (way too long)
let g:syntastic_asciidoc_checkers=[]

" disable ycm syntastic
" let g:syntastic_c_checkers=['gcc']
" let g:syntastic_cpp_checkers=['gcc']
let g:ycm_register_as_syntastic_checker = 1

" do not always ask to lod python .ycm_extra_conf.py
let g:ycm_confirm_extra_conf = 0

" close preview after accept
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_autoclose_preview_window_after_insertion = 1
" finally, not preview windows at all
let g:ycm_add_preview_to_completeopt = 0

"let g:syntastic_debug = 0
"let g:syntastic_debug_file = '/tmp/syntastic.log'

]])
LUA
:lua << LUA

-- ]]]
-- [[[ GitGutter opts

vim.wo.signcolumn = "yes"

-- nnoremap <Leader>hs <Plug>GitGutterStageHunk
-- nnoremap <Leader>hr <Plug>GitGutterRevertHunk

LUA
:lua << LUA

require('gitsigns').setup{
on_attach = function(bufnr)
    local gs = package.loaded.gitsigns

    local function map(mode, l, r, opts)
      opts = opts or {}
      opts.buffer = bufnr
      vim.keymap.set(mode, l, r, opts)
    end

    -- Navigation
    map('n', ']c', function()
      if vim.wo.diff then return ']c' end
      vim.schedule(function() gs.next_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    map('n', '[c', function()
      if vim.wo.diff then return '[c' end
      vim.schedule(function() gs.prev_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    -- Actions
    map({'n', 'v'}, '<leader>hs', ':Gitsigns stage_hunk<CR>')
    map({'n', 'v'}, '<leader>hr', ':Gitsigns reset_hunk<CR>')
    map('n', '<leader>hS', gs.stage_buffer)
    map('n', '<leader>hu', gs.undo_stage_hunk)
    map('n', '<leader>hR', gs.reset_buffer)
    map('n', '<leader>hp', gs.preview_hunk)
    map('n', '<leader>hb', function() gs.blame_line{full=true} end)
    map('n', '<leader>tb', gs.toggle_current_line_blame)
    map('n', '<leader>hd', gs.diffthis)
    map('n', '<leader>hD', function() gs.diffthis('~') end)
    map('n', '<leader>td', gs.toggle_deleted)

    -- Text object
    map({'o', 'x'}, 'ih', ':<C-U>Gitsigns select_hunk<CR>')
end
}

LUA
:lua << LUA

-- ]]]
-- [[[ Slime opts

if vim.env.TMUX
then
  -- XXX C-c might be intercepted if timeoutlen is too low
  vim.g.slime_target = "tmux"
  local socket_name = vim.fn.split(vim.env.TMUX, ",")[1]
  vim.g.slime_default_config = {
  	socket_name = socket_name,
  	target_pane = "{last}", -- ":.1"
	}
  vim.g.slime_dont_ask_default = 1
  -- for ipython set %autoindent to OFF
  vim.g.slime_python_ipython = 1
  vim.g.slime_paste_file = "{{env_var "HOME"}}/.slime_paste"
  vim.g.slime_dispatch_ipython_pause = 100
  vim.g.slime_bracketed_paste = 1
end

-- ]]]
-- [[[ 'a' module options

-- a.vim
vim.g.alternateRelativeFiles   = 1
vim.g.alternateExtensions_blk  = "h"
vim.g.alternateExtensions_blkk = "h"
vim.g.alternateExtensions_h    = "c,cpp,cxx,cc,CC,blk,blkk"
vim.g.alternateSearchPath = 'sfr:../src,sfr:../../src,sfr:../include'

-- ]]]
-- [[[ LSP

-- rust
local rt = require("rust-tools")
rt.setup({
  server = {
    on_attach = function(_, bufnr)
      -- Hover actions
      vim.keymap.set("n", "<C-space>", rt.hover_actions.hover_actions, { buffer = bufnr })
      -- Code action groups
      vim.keymap.set("n", "<Leader>a", rt.code_action_group.code_action_group, { buffer = bufnr })
    end,
  },
})

-- Enable inlay hints auto update and set them for all the buffers
rt.inlay_hints.enable()

vim.cmd("packadd rustaceanvim")
vim.g.rustaceanvim = {
  -- Plugin configuration
  tools = {
  },
  -- LSP configuration
  server = {
    on_attach = function(client, bufnr)
      -- Hover actions
      vim.keymap.set("n", "<C-space>", rt.hover_actions.hover_actions, { buffer = bufnr })
      -- Code action groups
      vim.keymap.set("n", "<Leader>a", rt.code_action_group.code_action_group, { buffer = bufnr })
    end,
    settings = {
      -- rust-analyzer language server configuration
      ['rust-analyzer'] = {
      },
    },
  },
  -- DAP configuration
  dap = {
  },
}

-- LSP using builtin neovim
vim.g['airline#extensions#nvimlsp#enabled'] = 1

-- LSP shortcuts
lsp = require('lspconfig') -- XXX no local, as used later
vim.lsp.set_log_level('off')
-- https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
    local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
    local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

    --Enable completion triggered by <c-x><c-o>
    buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

    -- Mappings.
    local opts = { noremap=true, silent=true }

    -- See `:help vim.lsp.*` for documentation on any of the below functions
    buf_set_keymap('n', 'gD', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
    buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
    buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
    buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
    buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
    buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
    buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
    buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
    buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
    buf_set_keymap('n', '<space>r', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
    buf_set_keymap('n', '<space>c', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
    buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
    buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
    buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
    buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
    buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
    buf_set_keymap('n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)
end

-- rust
lsp.rust_analyzer.setup {
    on_attach = on_attach
}

-- python
lsp.pylsp.setup {
  whitelist = { 'python' },
  -- root_dir = function(fname)
  --     return lsp.util.find_git_ancestor(fname) or vim.loop.os_homedir()
  -- end;
  settings = {
    pylsp = {
      plugins = {
        pycodestyle = {
          ignore = {'W391', },
          maxLineLength = 100
        }
      }
    }
  },
  on_attach = on_attach
}

-- C++
lsp.clangd.setup {
  on_attach = on_attach
}

-- ]]]
-- [[[ gundo/mundo/undotree

vim.cmd("packadd undotree")
vim.g.undotree_WindowLayout = 2 -- full width diff
vim.g.undotree_SplitWidth = 40 -- default (30) is too short
vim.g.undotree_SetFocusWhenToggle = 1 -- get focus on toggle
vim.api.nvim_set_keymap('n', '<F5>', ':UndotreeToggle<CR>', { noremap = true })

vim.opt.undofile = true

-- ]]]
-- [[[ vimwiki

vim.cmd("packadd vimwiki")
-- let wiki = {}
-- let wiki.nested_syntaxes = {'bash': 'sh', 'python': 'python', 'c++': 'cpp', 'rust': 'rust'}
-- let g:vimwiki_list = [wiki]

-- ]]]
-- [[[ user colors

LUA

" define at end as all plugin try to clear colors
hi User1 term=inverse,bold ctermfg=DarkBlue ctermbg=Black
hi User2 term=inverse,bold ctermfg=DarkRed ctermbg=Black
hi User3 term=inverse,bold ctermfg=DarkMagenta ctermbg=Black
hi User4 term=inverse,bold ctermfg=DarkGreen ctermbg=Black
hi User5 term=inverse,bold ctermfg=DarkYellow ctermbg=Black
hi User6 term=inverse,bold ctermfg=DarkCyan ctermbg=Black
hi User7 term=inverse,bold ctermfg=White ctermbg=Black

" xit treesitter colors plugin broken when retrieving hi colors from theme
if has('nvim')
  hi! link @XitHeadline Todo " \o/ meta! \o/ red/pink

  hi! link @XitOpenCheckbox Type " yellow
  hi! link @XitOpenTaskMainLine Normal
  hi! link @XitOpenTaskOtherLine Normal
  hi! link @XitOpenTaskPriority Error

  hi! link @XitOngoingCheckbox Identifier " blue
  hi! link @XitOngoingTaskMainLine Identifier
  hi! link @XitOngoingTaskOtherLine Identifier
  hi! link @XitOngoingTaskPriority Error

  hi! link @XitCheckedCheckbox Comment " grey
  hi! link @XitCheckedTaskMainLine Comment
  hi! link @XitCheckedTaskOtherLine Comment
  hi! link @XitCheckedTaskPriority DiagnosticError

  hi! link @XitObsoleteCheckbox Comment " grey
  hi! link @XitObsoleteTaskMainLine LineNr
  hi! link @XitObsoleteTaskOtherLine LineNr
  hi! link @XitObsoleteTaskPriority DiagnosticInfo
endif
" ]]]

" dotter/handlebars+fold incompatibility: temporary [ instead of {
" vim: foldmarker=[[[,]]]
" vim: filetype=vim
