export PATH=${HOME}/bin:$PATH

# [[[ own installs

export PATH=${HOME}/utils/git_install/bin/:${PATH}
export MANPATH=${HOME}/utils/git_install/share/man/:${MANPATH}

export PATH=${HOME}/utils/tig_install/bin/:${PATH}
export MANPATH=${HOME}/utils/tig_install/share/man/:${MANPATH}

export PATH=${HOME}/utils/gcc_install/bin/:${PATH}
export MANPATH=${HOME}/utils/gcc_install/share/man/:${MANPATH}

export PATH=${HOME}/utils/gdb_install/bin/:${PATH}
export MANPATH=${HOME}/utils/gdb_install/share/man/:${MANPATH}

export PATH=${HOME}/utils/neovim_install/bin/:${PATH}
export MANPATH=${HOME}/utils/neovim_install/share/man/:${MANPATH}

export PATH=${HOME}/utils/tmux_install/bin/:${PATH}
export MANPATH=${HOME}/utils/tmux_install/share/man/:${MANPATH}

export PATH=${HOME}/utils/llvm_install/bin/:${PATH}
export MANPATH=${HOME}/utils/llvm_install/share/man/:${MANPATH}
if type llvm-symbolizer &> /dev/null; then
    # FIXME safe which
    export ASAN_SYMBOLIZER_PATH="$(which llvm-symbolizer)"
fi
export ASAN_OPTIONS=abort_on_error=1:detect_leaks=1
export LSAN_OPTIONS=use_stacks=0:use_registers=0:use_globals=1:use_tls=1

export PATH=${HOME}/utils/fish_install/bin/:${PATH}
export MANPATH=${HOME}/utils/fish_install/share/man/:${MANPATH}

export TMUX_INSTALL=${HOME}/utils/tmux_install
export PATH=${TMUX_INSTALL}/bin/:${PATH}
export MANPATH=${TMUX_INSTALL}/share/man/:${MANPATH}

# ]]]

export LANGUAGE=en_US:en
export LANG='C.UTF-8' # never 12H AM/PM stupid date format

# export MALLOC_CHECK_=2
ulimit -c unlimited

# [[[ aliases
# [[[ misc

    alias ls='/bin/ls --color=tty'
    alias ll='ls -lrth'
    alias llo='ls -lh'
    alias lla='ll -a'
    alias grep='grep --color=auto'
    alias psu='ps -flwu $USER w f'
    alias topu='top -u $USER'
    alias cutd="cut -d' '"
    alias trs='tr -s "  " " " | sed -e "s/^\s*//"'
    alias less='less -WsJ -j3 -x2'
    alias lless='less -WsNJ -j3 -x2'

    function mkcd() {
            mkdir -p -- "$1" && cd -P -- "$1"
    }
    function cdmk() {
            mkdir -p -- "$1" && cd -P -- "$1"
    }

    alias f='find . -name '
    alias l='less '
    alias p='pstree -ap | less '
    alias m='make '
    alias mv='make VERBOSE=1 '
    alias gdb='gdb -q'

    alias style='~/bin/astyle --indent=spaces=4 --style=linux --max-instatement-indent=40 --min-conditional-indent=2 --pad-oper --pad-header --unpad-paren --break-elseifs --align-pointer=name'

    alias automirror='AUTOMIRROR_PRIMARY_DISPLAY=eDP1 AUTOMIRROR_NOTIFY_COMMAND=echo ~/dotfiles/bash/automirror.sh'
    alias fixcursor='echo -en "\e]50;CursorShape=0\x7"'
    alias fixcursortmux='echo -en "\e[0 q"'

    alias composekeylist='cat "/usr/share/X11/locale/$(grep --max-count=1 "${LANG%.*}.UTF-8\$" /usr/share/X11/locale/locale.dir | cut --delimiter=/ --fields 1)/Compose"'

    set history=50000
    #set savehist=(10000 merge)

    #command starting with ' ' aren't recorded
    export HISTCONTROL=ignoreboth
    alias h='history'

    alias i='ipython'
    alias is='PYTHONNOUSERSITE=on ipython'

    # conda
    alias condainit='source /opt/conda/etc/profile.d/conda.sh'

# ]]]
# [[[ tmux

    # Predictable SSH authentication socket location for tmux
    # tmuxssh-add will force reset
    SOCK="/tmp/ssh-agent-$USER-screen"
    export SSH_AUTH_SOCK=$SOCK

    alias tmuxssh-add='rm -f $SSH_AUTH_SOCK ; kill -9 $(pidof ssh-agent) ; ssh-agent -a $SSH_AUTH_SOCK && ssh-add'

    alias tmuxa='tmux -2 att -d -t'
    alias tmuxl='tmux ls'
    alias tmuxn='tmux -2 new -s'
    function tmuxd {
        tmux select-layout even-vertical 1>/dev/null 2>/dev/null
        tmux split-window
        sleep 1 # perfectibleâ„¢
        tmux send-keys "$@"
        tmux send-keys 'C-m'
    }
    # tmux aware pstree (with sessions/windows/pane info)
    # FIXME slow!
    function tmuxps {
        for s in $(tmux list-sessions -F "#{session_name}")
        do
            for p in $(tmux list-panes -s -F "#{window_name} #{window_index}.#{pane_index} [#{pane_pid}]" -t "$s" | sed "s@ @_@g")
            do
                export w=$(echo $p | sed "s@\(.*\)_\[.*@\1@; s@_@ @")
                export b=$(echo $p | sed "s@.*\[\(.*\)\]@\1@g")
                pstree -ap -U -p $b | grep -v ",${b}$" | sed "s@^@$s:\t$w:\t@"
            done
        done
    }
    function tmuxps2 {
        for s in $(tmux list-sessions -F "#{session_name}")
        do
            for p in $(tmux list-panes -s -F "#{window_name}\\t#{window_index}.#{pane_index}\\t[#{pane_pid}]" -t "$s")
            do
                echo p:$p
                export w=$(echo $p | sed "s@\(.*\)_\[.*@\1@; s@_@ @")
                export b=$(echo $p | sed "s@.*\[\(.*\)\]@\1@g")
                export prefix="$s:\t$w:\t"
                pstree -ap -U -p $b | grep -v ",${b}$" | sed "s@^@$prefix@"
            done
        done
    }

# ]]]
# [[[ git

    alias g='git'

    alias gem='${EDITOR} $(git status --ignore-submodules --porcelain | grep --color=no "^[ M]M" | trs | cut -d" " -f2)'
    alias ges='${EDITOR} $(git status --ignore-submodules --porcelain | grep --color=no "^M" | trs | cut -d" " -f2)'
    alias ge='${EDITOR} $(git status --ignore-submodules --porcelain | grep --color=no "^[ M][ M]" | trs | cut -d" " -f2)'
    alias gep='${EDITOR} $(git show --pretty="format:" --name-only)'

    alias gt='cd $(git-top)'

    alias gst='/usr/bin/git status'

    alias t='tig --date-order -500'

    # go to the upper git repo head (returned value is correct)
    alias up='export A=$(pwd); while git rev-parse --show-toplevel 1> /dev/null 2> /dev/null ; do export A=$(git rev-parse --show-toplevel 2> /dev/null) ; cd $A/.. ; done ; cd $A; unset A; git rev-parse --show-toplevel 1> /dev/null 2> /dev/null'

    #complete -o default -o nospace -F _git g
    #. /usr/share/stgit/completion/stgit-completion.bash
    #__git_complete g __git_main
    #complete -o bashdefault -o default -o nospace -F _git g 2>/dev/null \
    #    || complete -o default -o nospace -F _git g
    #complete -o bashdefault -o default -o nospace -F __git_wrap__git_main g 2>/dev/null \
    #    || complete -o default -o nospace -F __git_wrap__git_main g

    alias gl='/usr/bin/git logp -10'
    alias gll='/usr/bin/git logp -25'
    alias glll='/usr/bin/git logp -50'
    alias gllll='/usr/bin/git logp -87'

    alias gs='/usr/bin/git st'
    alias gv='/usr/bin/git v'
    alias ga='/usr/bin/git add'
    alias gc='/usr/bin/git commit'
    alias gr='grep --color'
    alias ggr='/usr/bin/git gr'

    alias tempo='/usr/bin/git commit -m tempo -a'

    if [[ -n $PS1 ]]; then
        # to get git complete functions NOW
        if [[ -r "/usr/share/bash-completion/completions/git" ]]; then
            . /usr/share/bash-completion/completions/git
        elif [[ -r "/home/richard/dotfiles/git/completions_git" ]]; then
            . /home/richard/dotfiles/git/completions_git
        fi

        __git_complete g __git_main
        __git_complete t _git_show
        __git_complete gl _git_show
        __git_complete gll _git_show
        __git_complete glll _git_show
        __git_complete gllll _git_show
        __git_complete gc _git_add
        __git_complete gc _git_commit
        __git_complete ggr _git_grep
    fi #PS1

    # flat list of branches, for using in scripts
    alias gbr='/usr/bin/git branch | sed "s/\*//" | sed "s/^\s*//"'

# ]]]
# [[[ editor

    if [[ -r "${HOME}/utils/neovim_install/bin/nvim" ]]; then
        export EDITOR=${HOME}/utils/neovim_install/bin/nvim
        export MANPAGER='nvim +Man!'

        alias vim=$EDITOR
        alias vimdiff='nvim -d'
    else
        export EDITOR='vim'
        export MANPAGER="/bin/sh -c \"unset PAGER;col -b -x | vim -R -c 'set ft=man nomod nolist nonumber norelativenumber readonly' -c 'map q :q<CR>' -c 'map <SPACE> <C-D>' -\""
    fi

    alias v='$EDITOR '
    alias va='$EDITOR ~/dotfiles/start.txt'
    alias vr='$EDITOR -R'
    alias vl='$EDITOR -S ~/.cache/session.vim'
    function vimlight {
        env $EDITOR --cmd "let theme = 'light'" $@
    }
    function vimlightl {
        env $EDITOR -S ~/.cache/session.vim --cmd "let theme = 'light'" $@
    }

# ]]]

# ]]]
# [[[ interactiv only settings

if [[ -n $PS1 ]]; then
    export LS_COLORS='no=00:fi=00:di=00;94:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=00;32:*.bat=00;32:*.sh=00;32:*.csh=00;32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;31:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;35:*.xbm=00;35:*.xpm=00;35:*.png=00;35:*.tif=00;35:*.c=00;96:*.h=00;95:*.py=00;92'

    # activate **
    shopt -s globstar

    # starship
    if type starship &> /dev/null; then
        eval "$(starship init bash)"
    else
        # old PS1 as backup method
        # [[[ PS1 with some info

        # from http://www.git-attitude.fr/2010/07/14/le-prompt-bash-qui-change-la-vie-avec-git/
        # Scavenged from Git 1.6.5.x contrib/completion/git_completion.bash
        # __git_ps1 accepts 0 or 1 arguments (i.e., format string)
        # returns text to add to bash PS1 prompt (includes branch name)
        __gitdir ()
        {
        if [ -z "${1-}" ]; then
            if [ -n "${__git_dir-}" ]; then
                echo "$__git_dir"
            elif [ -d .git ]; then
                echo .git
            else
                git rev-parse --git-dir 2>/dev/null
            fi
        elif [ -d "$1/.git" ]; then
            echo "$1/.git"
        else
            echo "$1"
        fi
        }
        __git_ps1 ()
        {
        local g="$(__gitdir)"
        if [ -n "$g" ]; then
            local r
            local b
            if [ -f "$g/rebase-merge/interactive" ]; then
                r="|REBASE-i"
                b="$(cat "$g/rebase-merge/head-name")"
            elif [ -d "$g/rebase-merge" ]; then
                r="|REBASE-m"
                b="$(cat "$g/rebase-merge/head-name")"
            else
            if [ -d "$g/rebase-apply" ]; then
                if [ -f "$g/rebase-apply/rebasing" ]; then
                    r="|REBASE"
                elif [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM"
                else
                    r="|AM/REBASE"
                fi
            elif [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING"
            elif [ -f "$g/BISECT_LOG" ]; then
                r="|BISECTING"
            fi

            b="$(git symbolic-ref HEAD 2>/dev/null)" || {

                b="$(
                case "${GIT_PS1_DESCRIBE_STYLE-}" in
                (contains)
                    git describe --contains HEAD ;;
                (branch)
                    git describe --contains --all HEAD ;;
                (describe)
                    git describe HEAD ;;
                (* | default)
                    git describe --exact-match HEAD ;;
                esac 2>/dev/null)" ||

                b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." ||
                b="unknown"
                b="($b)"
            }
            fi

            local w
            local i
            local s
            local u
            local c

            if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
            if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
                c="BARE:"
            else
                b="GIT_DIR!"
            fi
            elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ]; then
                if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                    git diff --no-ext-diff --ignore-submodules \
                    --quiet --exit-code || w=" *"
                    if git rev-parse --quiet --verify HEAD >/dev/null; then
                        git diff-index --cached --quiet \
                        --ignore-submodules HEAD -- || i=" +"
                    else
                        i=" #"
                    fi
                fi
            fi
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
                git rev-parse --verify refs/stash >/dev/null 2>&1 && s=" S"
            fi

            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
                if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                    u=" U"
                fi
            fi
            fi

            if [ -n "${1-}" ]; then
                printf "$1" "$c${b##refs/heads/}$w$i$s$u$r"
            else
                printf " (%s)" "$c${b##refs/heads/}$w$i$s$u$r"
            fi
        fi
        }

        export GIT_PS1_SHOWDIRTYSTATE=1
        export GIT_PS1_SHOWUNTRACKEDFILES=1
        export GIT_PS1_SHOWSTASHSTATE=1
        export GIT_PS1_DESCRIBE_STYLE="branch"

        #export PS1='\[\033[0;37m\]\u@\h:\[\033[0;33m\]\W\[\033[0m\]\[\033[1;32m\]$(__git_ps1)\[\033[0m\] \$ '

        export PROMPT_COMMAND=__exit_status
        function __exit_status() {
            local EXIT="$?"
            if [ $EXIT != 0 ]; then
                export PS1_EXIT_E="${EXIT} $"
                export PS1_EXIT=""
            else
                export PS1_EXIT_E=""
                export PS1_EXIT="$"
            fi
            # only evaluate hostname once
            #export SHORT_HOSTNAME=${SHORT_HOSTNAME-$(hostname | sed 's/.cfm.fr//')}
            export SHORT_HOSTNAME="unknown"
            if type hostname &> /dev/null
            then
                export SHORT_HOSTNAME=$(hostname -s)
            fi
        }

        PS1='[\t] \[\e[34;1m\]@\[\e[32;1m\]${SHORT_HOSTNAME}\[\033[1;31m\]$(__git_ps1)\[\033[0m\] \w \[\e[31;1m\]${PS1_EXIT_E}\[\e[0m\]\[\e[36;1m\]${PS1_EXIT}\[\e[0m\] '
        # PS1='[\t] \[\e[34;1m\]@\[\e[32;1m\]${SHORT_HOSTNAME} ${ALIAS_HOSTNAME}\[\033[1;31m\]$(__git_ps1)\[\033[0m\] \w \[\e[31;1m\]${PS1_EXIT_E}\[\e[0m\]\[\e[36;1m\]${PS1_EXIT}\[\e[0m\] '

        # ]]]
    fi

    # [[[ own keymap

    if type bind &> /dev/null && type stty &> /dev/null
    then
        bind "\C-f":forward-word
        bind "\C-g":forward-backward-delete-char
        #see stty -a
        stty lnext undef #^V
        bind "\C-v":forward-char
        stty werase undef #^W
        stty eof undef #^D
        bind "\C-h":backward-delete-char
        bind "\C-j":backward-word
        bind "\C-n":backward-char
        bind "\C-p":previous-history #def
        bind "\C-o":next-history
        bind "\C-d":kill-word
        #personal mapping:
        # w[<-EATW]                      o[HIST-] p[HIST-]
        # d[EATW->] f[word->] g[eat->] h[<-eat] j[<-word]
        #                v[->]              n[<-]  m[ENTER]
    fi

    # ]]]
fi #PS1

# ]]]

#set -o vi

# dotter/handlebars+fold incompatibility: temporary [[[ / ]]]]
# vim: foldmarker=[[[,]]]
